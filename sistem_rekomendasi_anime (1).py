# -*- coding: utf-8 -*-
"""Sistem Rekomendasi Anime.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nmsl9sdHBC74DO2NdkORVm9gHvCDEk8j

# **Import Package**
"""

# Pustaka untuk mengolah dan visualisasi data
from google.colab import files
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.neighbors import NearestNeighbors

"""# **Data Loading**"""

#Menampilkan dataset
import pandas as pd
nel = pd.read_csv('animedataset.csv')
nel

"""# **EDA (Exploratory Data Analysis)**"""

#Menampilkan info dataset
nel.info()

"""**Ringkasan:**
* terdapat 24 kolom dan 24905 baris
* terdapat 20 kolom dengan tipe data object dan 4 kolom dengan tipe data int(64)
* Berdasarkan data tersebut bisa disimpulkan bahwa terdapat 20 fitur kategori dan 4 fitur numerik.

**Penjelasan kolom dataframe:**

* anime_id: ID unik yang digunakan untuk mengidentifikasi setiap entri anime dalam dataset.

* Name: Nama asli anime dalam bahasa Jepang atau sebagaimana tertulis di sumber asli.

* English name: Nama anime dalam bahasa Inggris, jika tersedia.

* Other name: Nama lain atau alternatif dari anime, termasuk terjemahan atau nama pendek.

* Score: Skor rata-rata yang diberikan oleh pengguna terhadap anime tersebut (format saat ini adalah string dan perlu dikonversi ke numerik).

* Genres: Daftar genre yang menggambarkan kategori atau tema utama dari anime (misalnya Action, Comedy, Romance).

* Synopsis: Ringkasan cerita atau sinopsis dari anime.

* Type: Jenis format dari anime, seperti TV, Movie, OVA, ONA, atau Special.

* Episodes: Jumlah total episode yang dimiliki oleh anime (dalam format string dan mungkin perlu dibersihkan).

* Aired: Periode waktu penayangan anime, biasanya berupa rentang tanggal mulai dan berakhirnya.

* Premiered: Musim dan tahun rilis awal anime, seperti "Spring 2012" atau "Fall 2020".

* Status: Status penayangan anime, misalnya "Finished Airing", "Currently Airing", atau "Not yet aired".

* Producers: Perusahaan atau individu yang terlibat dalam pendanaan dan produksi anime.

* Licensors: Pihak yang memiliki hak lisensi distribusi anime, biasanya untuk wilayah luar Jepang.

* Studios: Studio animasi yang memproduksi anime.

* Source: Sumber cerita asli dari anime, seperti manga, light novel, game, atau original.

* Duration: Durasi penayangan rata-rata per episode, misalnya "24 min. per ep."

* Rating: Kategori usia penonton yang disarankan, seperti PG-13, R+, atau G.

* Rank: Peringkat anime berdasarkan skor dibandingkan dengan anime lainnya (berformat string, perlu dibersihkan jika ingin dianalisis secara numerik).

* Popularity: Peringkat popularitas berdasarkan jumlah anggota atau pengguna yang menambahkan anime ke daftar mereka.

* Favorites: Jumlah pengguna yang menandai anime tersebut sebagai favorit.

* Scored By: Jumlah pengguna yang memberikan skor pada anime (masih dalam format string, perlu dikonversi ke numerik).

* Members: Jumlah total pengguna yang menambahkan anime ke dalam daftar mereka (watching, completed, plan to watch, dll.).

* Image URL: Link ke gambar atau poster anime.

Pada proyek sistem rekomendasi ini, meskipun dataset yang tersedia memiliki banyak fitur informatif, hanya beberapa fitur utama yang akan difokuskan untuk membangun model rekomendasi yang efisien dan sederhana. Fitur-fitur yang dipilih meliputi:

* Name: sebagai identitas utama dari anime,

* Score: untuk merepresentasikan penilaian atau preferensi pengguna,

* Genres: sebagai indikator utama konten dan tema,

* Type: untuk mengetahui jenis rilis (TV, Movie, dll),

* Studios: untuk mempertimbangkan kualitas dan gaya produksi yang khas dari masing-masing studio.


Pemilihan fitur ini didasarkan pada asumsi bahwa karakteristik konten (genre dan studio) serta persepsi pengguna (score) merupakan faktor penting dalam menentukan kemiripan antar anime.

Dalam pendekatan Content-Based Filtering, sistem akan merekomendasikan anime berdasarkan kemiripan konten, seperti genre dengan anime yang disukai pengguna sebelumnya. Sedangkan KNN  sistem akan merekomendasikan anime berdasarkan ke,iripan konten seperti fitur Name, Genres, Type, Score dan Studios menjadi kunci utama dalam proses ini.

Meskipun terdapat fitur-fitur tambahan seperti sinopsis, tanggal penayangan, atau jumlah episode yang juga berpotensi meningkatkan performa model, fitur-fitur tersebut tidak dimanfaatkan dalam tahap awal ini demi menjaga kompleksitas tetap rendah. Namun, fitur tambahan tersebut dapat dijadikan bahan eksplorasi pada pengembangan model di masa mendatang.
"""

# Cek kolom dengan duplicate
nel.duplicated().sum()

"""Dataset tersebut tidak memiliki duplikat sehingga bisa dilanjutkan untuk memeriksa apakah data mengalami missing value."""

# Cek kolom dengan missing value
nel.isnull().sum()

"""Dataset tersebut tidak mengalami missing value sehingga bisa dilanjutkan dengan tahap visualisasi agar kita bisa mendapatkan beberapa highlight dari dataset yang kita gunakan.

## **Visualisasi**
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Pisahkan genre yang dipisahkan koma dan hitung frekuensinya
genre_series = nel['Genres'].dropna().str.split(', ')
all_genres = genre_series.explode().value_counts().head(10)

plt.figure(figsize=(10,6))
sns.barplot(x=all_genres.values, y=all_genres.index, palette='viridis')
plt.title('Top 10 Genre Anime Terpopuler')
plt.xlabel('Jumlah Anime')
plt.ylabel('Genre')
plt.tight_layout()
plt.show()

"""**Interpretasi & Insight:**

* **Dominasi Genre Umum:** Terlihat jelas bahwa genre Comedy menempati posisi teratas sebagai genre yang paling sering muncul, diikuti oleh Action, Fantasy, dan Adventure. Ini menunjukkan bahwa sebagian besar anime dalam dataset cenderung memiliki elemen-elemen ini, yang mencerminkan popularitas genre-genre tersebut di kalangan penonton secara luas.

* **Keberagaman Menengah:** Genre seperti Drama, Sci-Fi, dan Romance juga memiliki frekuensi yang signifikan, menunjukkan keberagaman konten yang cukup baik meskipun ada dominasi genre teratas.

* **Genre Spesifik Populer:** Kehadiran School, Shounen, dan Slice of Life dalam 10 besar menandakan adanya segmen pasar atau tipe cerita yang kuat dan sering diproduksi dalam industri anime.
"""

# Pastikan kolom Score dalam bentuk float
nel['Score'] = pd.to_numeric(nel['Score'], errors='coerce')

# Plot ulang dengan bins yang wajar
plt.figure(figsize=(10,5))
sns.histplot(nel['Score'].dropna(), bins=20, kde=True, color='skyblue')
plt.title('Distribusi Skor Anime')
plt.xlabel('Skor')
plt.ylabel('Jumlah Anime')
plt.grid(True)
plt.tight_layout()
plt.show()

"""**Interpretasi dan Insight:**

* **Distribusi skor anime berbentuk normal**, dengan mayoritas skor berada di antara 6 hingga 7, dan puncaknya sekitar 6.5. Ini menunjukkan bahwa sebagian besar anime memiliki kualitas yang tergolong baik.

* **Anime dengan skor sangat rendah (< 4) dan sangat tinggi (> 8.5)** sangat jarang ditemukan, menunjukkan konsistensi kualitas dalam industri anime.

* **Skor dapat digunakan sebagai indikator awal dalam sistem rekomendasi**, dengan menetapkan threshold (misalnya skor ≥ 6) untuk memfilter anime yang layak direkomendasikan kepada pengguna.
"""

top_anime = nel[nel['Score'].notna()].sort_values(by='Score', ascending=False)
top_anime = top_anime[top_anime['Score'] > 0]
top_anime = top_anime.head(10)

plt.figure(figsize=(12,6))
sns.barplot(x='Score', y='Name', data=top_anime, palette='viridis')
plt.title('Top 10 Anime dengan Skor Tertinggi')
plt.xlabel('Skor')
plt.ylabel('Judul Anime')
plt.tight_layout()
plt.show()

"""**Interpretasi dan Insight:**

* **Fullmetal Alchemist:** Brotherhood menempati posisi teratas dengan skor tertinggi, yang menunjukkan popularitas dan kualitas cerita serta produksi yang sangat diakui oleh komunitas anime global.

* **Seri Gintama mendominasi daftar**, muncul sebanyak tiga kali dalam berbagai versi/sekuel, menunjukkan kekuatan fanbase yang besar dan konsistensi kualitas dari seri ini.

* **Genre action dan psychological** tampak dominan dalam daftar ini (misalnya: Steins;Gate, Attack on Titan, Hunter x Hunter), memberikan insight bahwa genre tersebut sangat disukai dan cenderung mendapat skor tinggi dari penonton.
"""

plt.figure(figsize=(10,6))
sns.countplot(data=nel, y='Type', order=nel['Type'].value_counts().index, palette='Set2')
plt.title('Distribusi Anime berdasarkan Type')
plt.xlabel('Jumlah Anime')
plt.ylabel('Type')
plt.tight_layout()
plt.show()

"""**Interpretasi dan Insight:**

* **Anime berformat TV** merupakan tipe paling dominan, dengan jumlah lebih dari 7.500 judul. Ini menunjukkan bahwa serial televisi adalah format paling umum dalam industri anime, kemungkinan karena memungkinkan pengembangan cerita yang lebih panjang dan mendalam.

* **Movie, OVA, dan ONA** juga cukup banyak diproduksi, menandakan bahwa format pendek seperti OVA dan ONA tetap memiliki pasar tersendiri, mungkin untuk eksperimen kreatif atau sebagai pendamping dari serial utama.

* **Kategori UNKNOWN** sangat sedikit dan bisa dianggap noise. Untuk keperluan analisis lanjutan, data dengan label UNKNOWN sebaiknya dipertimbangkan untuk dibersihkan atau dikecualikan agar tidak mengganggu hasil insight lainnya.
"""

# Ekstrak durasi angka dari string (dalam menit)
nel['Durasi_menit'] = nel['Duration'].str.extract(r'(\d+)').astype(float)

plt.figure(figsize=(10,6))
sns.histplot(nel['Durasi_menit'].dropna(), bins=30, kde=True, color='skyblue')
plt.title('Distribusi Durasi Anime (Menit per Episode)')
plt.xlabel('Durasi (menit)')
plt.ylabel('Jumlah Anime')
plt.tight_layout()
plt.show()

"""**Interpretasi dan Insight:**

* **Durasi paling umum** adalah sekitar 1–5 menit dan 24 menit per episode, dengan dua puncak distribusi yang sangat jelas. Ini menunjukkan bahwa anime didominasi oleh dua format durasi utama: anime pendek (biasanya ONA/OVA/special) dan durasi standar siaran TV (sekitar 24 menit).

* **Distribusi menunjukkan bentuk bimodal**, menandakan adanya dua kategori produksi yang berbeda secara signifikan: anime pendek untuk konten eksperimental atau humor ringan, dan anime standar untuk cerita penuh.

* **Durasi di atas 30 menit sangat jarang**, menandakan bahwa episode panjang (misalnya film berdurasi penuh yang dibagi menjadi bagian-bagian) merupakan pengecualian dan bukan format umum di industri anime.
"""

nel['Episodes'] = pd.to_numeric(nel['Episodes'], errors='coerce')
plt.figure(figsize=(10,5))
sns.histplot(nel['Episodes'].dropna(), bins=50, kde=True, color='orange')
plt.title('Distribusi Jumlah Episode Anime')
plt.xlabel('Jumlah Episode')
plt.ylabel('Jumlah Anime')
plt.xlim(0, 100)  # Biar gak keganggu anime super panjang
plt.grid(True)
plt.tight_layout()
plt.show()

"""**Interpretasi dan Insight:**

* **Mayoritas anime memiliki episode sangat sedikit (1–12 episode)**, yang umumnya berasal dari format pendek seperti OVA, ONA, atau mini series. Ini menunjukkan tren dominasi anime pendek di industri.

* **Jumlah anime menurun drastis seiring bertambahnya jumlah episode**, menunjukkan bahwa anime dengan episode panjang (30 ke atas) adalah minoritas dan lebih jarang diproduksi karena biaya dan durasi produksi yang lebih besar.

* **Distribusi bersifat right-skewed (condong ke kanan)**, artinya anime dengan jumlah episode tinggi seperti One Piece atau Naruto adalah outlier dan tidak mencerminkan mayoritas tren produksi anime.
"""

# Pastikan kolom Aired atau Year diolah dengan benar
nel['Year'] = pd.to_datetime(nel['Aired'], errors='coerce').dt.year

yearly_anime = nel['Year'].value_counts().sort_index()

plt.figure(figsize=(12,5))
sns.lineplot(x=yearly_anime.index, y=yearly_anime.values)
plt.title('Jumlah Anime Dirilis per Tahun')
plt.xlabel('Tahun')
plt.ylabel('Jumlah Anime')
plt.grid(True)
plt.tight_layout()
plt.show()

"""**Interpretasi dan Insight dari Grafik:**

1. **Pertumbuhan Lambat (1900–1980-an):**
* Hampir tidak ada anime dirilis secara masif sebelum tahun 1980.
* Ini wajar karena industri anime modern baru benar-benar berkembang setelah teknologi animasi membaik dan TV menjadi umum.

2. **Peningkatan Signifikan (1980–2000-an):**
* Ada kenaikan stabil sejak 1980-an. Ini seiring dengan popularitas global anime dan pertumbuhan studio seperti Ghibli, Toei, dll.

3. **Puncak Produksi (2010–2021):**
* Jumlah rilisan melonjak pesat, bahkan mencapai lebih dari 600 judul per tahun.
* Bisa dikaitkan dengan era digital, streaming platform (Crunchyroll, Netflix), dan lonjakan minat global terhadap anime.

4. **Penurunan Tajam Setelah 2021:**
* Data tahun 2022 ke atas menunjukkan penurunan drastis, kemungkinan besar data belum lengkap atau belum diupdate, bukan karena produksi menurun drastis.


"""

# Ubah kolom Members menjadi numerik (kalau belum)
nel['Members'] = pd.to_numeric(nel['Members'], errors='coerce')

# Ambil 10 anime dengan members terbanyak
top_members = nel.sort_values(by='Members', ascending=False).head(10)

# Plot
plt.figure(figsize=(12,6))
sns.barplot(x='Members', y='Name', data=top_members, palette='coolwarm')
plt.title('Top 10 Anime dengan Jumlah Komunitas (Members) Terbanyak')
plt.xlabel('Jumlah Members')
plt.ylabel('Judul Anime')
plt.tight_layout()
plt.show()

"""**Interpretasi dan Insight:**

1. **Anime Paling Populer secara Komunitas:**
* Shingeki no Kyojin (Attack on Titan) dan Death Note berada di puncak dengan lebih dari 3,7 juta members, menunjukkan betapa besarnya komunitas penggemar mereka di platform seperti MyAnimeList.
* Keduanya memiliki dampak global yang besar, bahkan menembus pasar non-anime biasa.

2. **Anime Shounen Dominasi Daftar:**
* 90% dari anime yang masuk top 10 berasal dari genre shounen atau aksi, memperlihatkan daya tarik genre ini yang sangat kuat di kalangan komunitas global.

3. **Keberadaan Anime Lama dan Baru:**
* Ada anime lama seperti Naruto dan Death Note, tapi juga ada yang relatif baru seperti Kimetsu no Yaiba dan Boku no Hero Academia, yang menunjukkan pertumbuhan komunitas tidak hanya tergantung usia anime.


"""

# Buang entri UNKNOWN
filtered_studio = nel[nel['Studios'].str.lower() != 'unknown']

# Hitung dan ambil top 10
top_studios = filtered_studio['Studios'].value_counts().head(10).reset_index()
top_studios.columns = ['Studios', 'Jumlah_Anime']

# Plot
plt.figure(figsize=(12,6))
sns.barplot(x='Jumlah_Anime', y='Studios', data=top_studios, palette='viridis')
plt.title('Top 10 Studio dengan Jumlah Produksi Anime Terbanyak')
plt.xlabel('Jumlah Anime')
plt.ylabel('Studio')
plt.tight_layout()
plt.show()

"""**Interpretasi dan Insight**:

1. **Toei Animation sebagai Studio Paling Produktif**
* Toei Animation menempati posisi teratas dengan lebih dari 800 judul anime, jauh mengungguli studio lain. Ini menunjukkan dominasi kuat Toei dalam industri anime, yang dikenal memproduksi serial populer seperti One Piece dan Dragon Ball.

2. **Kompetisi Ketat di Antara Studio Menengah**
* Studio seperti Sunrise, J.C. Staff, dan Madhouse memiliki jumlah produksi yang relatif berdekatan, berkisar antara 300–500 judul. Ini menunjukkan persaingan ketat di antara studio menengah yang tetap aktif dan produktif dalam industri.

3. **Studio Tertua Cenderung Lebih Banyak Produksi**
* Mayoritas studio yang masuk 10 besar adalah studio yang telah berdiri sejak era 70–80-an, yang memungkinkan mereka membangun portofolio besar seiring waktu. Ini menandakan bahwa umur studio berkontribusi signifikan terhadap total produksi.

# **Data Cleaning**
"""

# Cek kolom dengan duplicate
nel.duplicated().sum()

# Cek kolom dengan missing value
nel.isnull().sum()

# Daftar kolom yang akan di-drop akibat dari visualisasi sehingga terdapat penambahan kolom
drop_cols = ['Durasi_menit','Year']

# Drop kolom
nel.drop(columns=drop_cols, inplace=True)

# Ganti 'Unknown' dengan NaN
nel['Score'] = nel['Score'].replace('UNKNOWN', np.nan)
nel['Episodes']=nel['Episodes'].replace('UNKNOWN',np.nan)
nel.dropna(subset=['Score', 'Episodes'], inplace=True)

# Cek kolom dengan missing value
nel.isnull().sum()

nel.info()

nel.describe().T

"""**Fungsi describe**() memberikan informasi statistik pada masing-masing kolom, antara lain:

* Count adalah jumlah sampel pada data.
* Mean adalah nilai rata-rata.
* Std adalah standar deviasi.
* Min yaitu nilai minimum setiap kolom.
* 25% adalah kuartil pertama. Kuartil adalah nilai yang menandai batas interval dalam empat bagian sebaran yang sama.
* 50% adalah kuartil kedua, atau biasa juga disebut median (nilai tengah). - * * 75% adalah kuartil ketiga.
* Max adalah nilai maksimum.

# **Data Preparation**
"""

import re

def text_cleaning(text):
  text = re.sub(r"[^\w\s]", "", text)
  text = re.sub(r"https?://[^\s]+", "", text)
  return text

nel['Name'] = nel['Name'].apply(text_cleaning)

#Membuang url yang tidak akan digunakan

#Membuang kolom yang tidak akan digunakan untuk model
columns_to_drop = ['anime_id',
    'English name',
    'Other name',
    'Episodes',
    'Synopsis',
    'Aired',
    'Premiered',
    'Status',
    'Producers',
    'Licensors',
    'Duration',
    'Source',
    'Rating',
    'Rank',
    'Popularity',
    'Favorites',
    'Scored By',
    'Members',
    'Image URL']
nel.drop(columns=columns_to_drop, inplace=True)

# memeriksa dataframe nel terbaru
nel.info()

# 1. Inisialisasi TfidfVectorizer
tf = TfidfVectorizer()

# 2. Melakukan perhitungan idf pada data genre
tf.fit(nel['Genres'])

from sklearn.preprocessing import OneHotEncoder, StandardScaler

# 1. Drop NaN pada fitur yang akan digunakan
nel_clean = nel.dropna(subset=['Score', 'Type', 'Studios']).copy()
nel_clean.reset_index(drop=True, inplace=True)

# 2. One-hot encoding
encoder = OneHotEncoder(handle_unknown='ignore')
encoded = encoder.fit_transform(nel_clean[['Type', 'Studios']]).toarray()
encoded_df = pd.DataFrame(encoded, columns=encoder.get_feature_names_out(['Type', 'Studios']))

# 3. Gabungkan dengan Score
features = pd.concat([nel_clean[['Score']].reset_index(drop=True), encoded_df], axis=1)

# 4. Pastikan tidak ada NaN
assert features.isnull().sum().sum() == 0, "Masih ada NaN!"

# 5. Scaling
scaler = StandardScaler()
features_scaled = scaler.fit_transform(features)

"""# **Model Development**

## **Model Content Based Filtering**
"""

nel

tf.get_feature_names_out()

# Melakukan fit lalu ditransformasikan ke bentuk matrix
tfidf_matrix = tf.fit_transform(nel['Genres'])

# Melihat ukuran matrix tfidf
tfidf_matrix.shape

# Mengubah vektor tf-idf dalam bentuk matriks dengan fungsi todense()
tfidf_matrix.todense()

pd.DataFrame(
    tfidf_matrix.todense(),
    columns=tf.get_feature_names_out(),
    index=nel.Genres
).sample(22, axis=1).sample(10, axis=0)

# Menghitung cosine similarity pada matrix tf-idf
cosine_sim = cosine_similarity(tfidf_matrix)
cosine_sim

# Membuat dataframe dari variabel cosine_sim dengan baris dan kolom berupa nama resto
cosine_sim_df = pd.DataFrame(cosine_sim, index=nel['Name'], columns=nel['Name'])
print('Shape:', cosine_sim_df.shape)

# Melihat similarity matrix pada setiap resto
cosine_sim_df.sample(5, axis=1).sample(10, axis=0)

def rekomendasi_anime(anime_name, similarity_data=cosine_sim_df, items=nel[['Name','Genres']], k=5):


    index = similarity_data.loc[:,anime_name].to_numpy().argpartition(
        range(-1, -k, -1))


    closest = similarity_data.columns[index[-1:-(k+2):-1]]
    closest = closest.drop(anime_name, errors='ignore')

    return pd.DataFrame(closest).merge(items).head(k)

nel[nel.Name.eq('Haikyuu')]

rekomendasi_anime('Haikyuu')

"""Hasil Pengujian Model Content Based Filtering (dengan Filter Genres)* menunjukkan bahwa model rekomendasi Top-5 memiliki presisi sempurna, yaitu 5 dari 5 atau 100%. Hal ini mengindikasikan bahwa model tersebut mampu menghasilkan rekomendasi dengan tingkat ketepatan yang sangat tinggi. Hasil pengujian memperlihatkan bahwa model berhasil merekomendasikan anime dengan nama dan genre yang sangat mirip dengan **Haikyuu**, terutama dalam genre Sports. Kelima rekomendasi yang ditampilkan semuanya memiliki genre yang sesuai dengan **Haikyuu**.

## **K-Nearest Neighbors (KNN)**
"""

nel.head()

from sklearn.neighbors import NearestNeighbors

# Fit model
knn = NearestNeighbors(metric='cosine', algorithm='brute')
knn.fit(features_scaled)

def recommend_anime(title, n=5):
    if title not in nel_clean['Name'].values:
        return f"'{title}' tidak ditemukan dalam dataset."

    idx = nel_clean[nel_clean['Name'] == title].index[0]
    anime_vector = features_scaled[idx].reshape(1, -1)

    distances, indices = knn.kneighbors(anime_vector, n_neighbors=n+1)

    result = nel_clean.iloc[indices[0][1:]][['Name', 'Score', 'Type', 'Studios']]
    result['Similarity'] = 1 - distances[0][1:]
    return result

recommend_anime('Death Note', n=5)

"""terlihat bahwa model K-Nearest Neighbor memberikan rekomendasi anime dengan mempertimbangkan kemiripan fitur seperti 'Name', 'Score', 'Type', dan 'Studios'. Model ini merekomendasikan anime yang memiliki karakteristik serupa dengan **Death Note**, yaitu *Hajime no Ippo New Challenger*, *Yojouhan Shinwa Taikei*, *Nana*, *Sora yori mo Tooi Basho*, dan *One Punch Man*. Seperti terlihat pada *Tabel 2*, tingkat kemiripan antar anime tersebut mencapai sekitar 99%. Dengan demikian, model ini sangat membantu pengguna dalam menemukan anime yang relevan dan mirip dengan **Death Note**.

# **Evaluasi**

**Metrik evaluasi** berfungsi untuk mengukur sejauh mana kinerja suatu model dalam menyelesaikan tugas yang diberikan. Dalam konteks ini, terdapat beberapa metrik yang umum digunakan untuk menilai performa model, salah satunya adalah precision. Metrik-metrik ini membantu memberikan pemahaman mengenai efektivitas model dalam melakukan tugas seperti klasifikasi atau pengelompokan (klastering) data.

**Presisi** merupakan salah satu metrik penting dalam mengevaluasi kinerja model klasifikasi. Metrik ini digunakan untuk menilai tingkat ketepatan model dalam mengidentifikasi data yang benar-benar termasuk dalam kelas positif. Nilai presisi yang tinggi mengindikasikan bahwa model jarang salah dalam memprediksi data sebagai positif, sehingga hasil prediksi positifnya cenderung dapat diandalkan.

Rumus presisi adalah sebagai berikut:
$$
\text{Presisi} = \frac{TP}{TP + FP}
$$

Dengan keterangan:

* **TP (True Positive)**: Jumlah data yang diklasifikasikan sebagai positif oleh model dan benar-benar merupakan data positif.

* **FP (False Positive)**: Jumlah data yang diklasifikasikan sebagai positif oleh model, padahal sebenarnya termasuk kategori negatif.

**Interpretasi dari hasil presisi** berdasarkan Hasil Pengujian Model Content Based Filtering (dengan Filter Genres). menunjukkan bahwa presisi model rekomendasi Top-5 adalah sempurna, yaitu 5/5 atau 100%. Ini menandakan bahwa model tersebut memberikan rekomendasi dengan tingkat presisi yang sangat tinggi, yakni 100%. Ini sesuai dengan hasil pengujian yang menunjukkan bahwa model mampu memberikan rekomendasi dengan nama dan genre yang mirip dengan anime Haikyuu, yaitu genre Sports. Hasil rekomendasi menampilkan lima aplikasi dengan genre yang serupa dengan Haikyuu
"""